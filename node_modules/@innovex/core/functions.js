const fs = require("fs");
const path = require('path');
const currentWorkingDir = process.cwd();


//console editing
var cl = {};
cl.log = console.log;
(function() {
	this.err = function (c) {
		cl.log("\x1b[31m\x1b[1m", c, '\x1b[0m');
		process.exit();
	}
	this.suc = function (c) {
		cl.log("\x1b[32m\x1b[1m", c, '\x1b[0m');
	}
	this.war = function (c) {
		cl.log("\x1b[33m\x1b[1m", c, '\x1b[0m');
	}
	this.nor = function (c) {
		cl.log("\x1b[37m\x1b[1m", c, '\x1b[0m');
	}
}.call(cl));


//Argument Validation
function argumentValidator(availableProperties, args) {
	const mandatoryProperties = availableProperties.mandatory;
	const optionalProperties = availableProperties.optional;
	var allProperties = [];

	// Check mandatory properties
	for (const property in mandatoryProperties) {
		if (property.includes("/") && (property in mandatoryProperties)) {
			const options = property.split("/");
			allProperties = allProperties.concat(options);
			switch (options.length) {
				case 2:
					if (args[options[0]] || args[options[1]]) {
						if (typeof args[options[0]] == mandatoryProperties[property] || typeof args[options[1]] == mandatoryProperties[property]) {} else {
							cl.err("typeof property doens't match with given properties");
						}
					} else {
						cl.err("'" + options[0] + " property' or '" + options[1] + " property' must be present");
					}
					break;
				case 3:
					if (args[options[0]] || args[options[1]] || args[options[2]]) {
						if (typeof args[options[0]] == mandatoryProperties[property] || typeof args[options[1]] == mandatoryProperties[property] || typeof args[options[2]] == mandatoryProperties[property]) {} else {
							cl.err("typeof property doens't match with given properties");
						}
					} else {
						cl.err("'" + options[0] + " property' or '" + options[1] + " property' must be present or '" + options[2] + " property' must be present with given type");
					}
					break;
				default:
					cl.err("You can't add more than 3 properties");
				}
			} else {
				allProperties.push(property)
				if (!(property in args)) {
					cl.err(property + ": property is mandatory");
				}
				const expectedType = mandatoryProperties[property];
				const actualType = typeof args[property];

				if (actualType != expectedType) {
					cl.err(property + ": property must be a " + expectedType);
				}
			}
		}


		// Check optional properties
		for (const property in optionalProperties) {
			allProperties.push(property);
			if (property in args) {
				const expectedType = optionalProperties[property];
				const actualType = typeof args[property];
				if (actualType != expectedType) {
					cl.err(property + ": property must be a " + expectedType);
				}
			}
		}

		//Checking if argument available
		for (i in args) {
			if (!allProperties.includes(i)) {
				cl.err("'"+i+"' property is not available");

			}
		}
		return true;
	}
	//File checker
	function fileChecker(filePath) {
		const file = path.join(currentWorkingDir, filePath);
		try {
			fs.accessSync(file, fs.constants.F_OK);
			return true;
		} catch (error) {
			cl.err(filePath +": file doesn't exist");

		}
	}

	//Exports

	module.exports = {
		fileChecker,
		argumentValidator,
		cl
	}